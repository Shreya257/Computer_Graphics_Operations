OpenGL program to illustrate lighting and shading

Problem Statement:
1.	Create a 3D model
2.	Define light properties
3.	Define material properties
4.	Demonstrate the lighting and shading effect



C++ Code:
(lightshade.cpp)

#include<windows.h>			// For MS windows #include <GL/glut.h>		// OpenGL Utilities Toolkit #include <GL/glu.h>		// OpenGL Utility Library #include <GL/gl.h>	// Core OpenGL
#include <stdio.h>	// For Standard Input/Output functions #include <math.h>		// For math functions
#include <stdlib.h>	// For general purpose standard library

/*Material properties of sphere 1*/ void drawSphere() {
GLfloat mat_specular[] = { 0.62, 0.55, 0.36, 1.0 }; GLfloat mat_shininess[] = { 51.2 };
GLfloat mat_ambient[] = { 0.24725, 0.1995, 0.0745, 1.0 };
GLfloat mat_diffuse[] = { 0.75164, 0.60648, 0.22648, 1.0 };
//Material Properties
glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient); glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse); glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular); glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
}

/*Material properties of sphere 2*/ void drawnSphere() {
GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 }; GLfloat mat_shininess[] = { 50.0 };
glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular); glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
}

/*Defines light model with material and light properties*/ void init(void)
{
 
GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 }; GLfloat mat_shininess[] = { 50.0 };
GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };
GLfloat light[] = { 1.0, 0.2, 0.2 };
GLfloat lmodel_ambient[] = { 0.1, 0.1, 0.1, 1.0 }; glClearColor(0.0, 0.0, 0.0, 1.0); // Set background color to black glShadeModel(GL_SMOOTH);	// Enable smooth shading

glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular); glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess); glLightfv(GL_LIGHT0, GL_POSITION, light_position);

glLightfv(GL_LIGHT0, GL_DIFFUSE, light); glLightfv(GL_LIGHT0, GL_SPECULAR, light); glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);

glEnable(GL_LIGHTING); // Enable Lighting glEnable(GL_LIGHT0);	// Enable Lighting glEnable(GL_DEPTH_TEST); // Enable depth testing
}

/*Display Function*/ void display(void)
{
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);	// Clear color and depth buffers
// sphere 1 glPushMatrix();
glTranslatef(-0.75, -0.8, 0.0);	// Translates sphere by factor specified drawSphere();	// Function call for sphere 1
glutSolidSphere(0.5, 50, 50);	// Renders solid sphere 1 with (GLdouble radius, GLint slices, GLint stacks)
glPopMatrix();
// sphere 2 glPushMatrix();
glTranslatef(1.0, 0.0, -1.0);		// Translates sphere by factor specified drawnSphere();	// Function call for sphere 2
glutSolidSphere(0.5, 50, 50);	// Renders solid sphere 2 with (GLdouble radius, GLint slices, GLint stacks)
glPopMatrix();

glFlush();
}

/* Handler for window re-size event. Called back when the window first appears and whenever the window is re-sized with its new width and height */
void reshape(int w, int h)
{
glViewport(0, 0, (GLsizei) w, (GLsizei) h); // Set the viewport to cover the new window glMatrixMode(GL_PROJECTION); // To operate on the Projection matrix glLoadIdentity();	// Reset
// Set up orthographic projection view (glOrtho view plane accordingly and the shapes defined according to view plane)
if (w <= h)
 
glOrtho(-1.5, 1.5, -1.5*(GLfloat)h/(GLfloat)w,
1.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0); else
glOrtho(-1.5*(GLfloat)w/(GLfloat)h, 1.5*(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);
glMatrixMode(GL_MODELVIEW); // To operate on the model-view matrix glLoadIdentity();	// Reset
}

int main(int argc, char** argv) // Main function
{
glutInit(&argc, argv);	// Initialize GLUT
glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH); // Enables different modes glutInitWindowSize(500, 500);		// Set the window's initial width & height glutInitWindowPosition(100, 100); // Position the window's initial top-left corner glutCreateWindow(argv[0]);	// Create window
init();	// initialization glutDisplayFunc(display); // Register callback handler glutReshapeFunc(reshape); // Register callback handler
glutMainLoop();	// Enter the infinite event-processing loop return 0;
}
