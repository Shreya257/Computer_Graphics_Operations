Composite Transformation


Problem Statement: Create a 3D object perform
1.	Rotate with respect to an arbitrary point by an angle of 45 degrees.
2.	Translate by a factor of dx=10, dy=10.
3.	Define the 2d ortho view plane accordingly and define the object according to view plane.



C++ Code:
(3dcomptransform.cpp)

#include <windows.h> // for MS windows #include <GL/glut.h> // GLUT

/* Global variables */
char title[] = "3D Shapes with Composite Transformations";
GLfloat angPyramid = 45.0f; // Rotational angle for pyramid (Rotates pyramid with respect to an arbitrary point by an angle of 45 degrees)
GLfloat angCube = 45.0f; // Rotational angle for cube (Rotates cube with respect to an arbitrary point by an angle of 45 degrees)
int refreshMills = 1; // refresh interval in milliseconds

/* Initialize OpenGL graphics */ void initGL() {
glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Set background color to black glClearDepth(1.0f); // Set background depth to farthest glEnable(GL_DEPTH_TEST); // Enable depth testing glDepthFunc(GL_LEQUAL); // Set the type of depth-test glShadeModel(GL_SMOOTH); // Enable smooth shading
glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Nice perspective corrections
}

void display() {
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Clear color and depth buffers
glMatrixMode(GL_MODELVIEW); // To operate on model-view matrix
//Cube
glLoadIdentity(); // Reset the model-view matrix
 
glTranslatef(10.0f, 10.0f, -7.0f); // Move right and into the screen (Translates cube by a factor of dx=10, dy=10)
glRotatef(angCube, 1.0f, 1.0f, 1.0f); // Rotate about (1,1,1)-axis glBegin(GL_QUADS); // Begin drawing the color cube with 6 quads // Top face (y
= 1.0f)
// Define vertices in counter-clockwise order glColor3f(0.0f, 1.0f, 0.0f); // Green glVertex3f(1.0f, 1.0f, -1.0f);
glVertex3f(-1.0f, 1.0f, -1.0f);
glVertex3f(-1.0f, 1.0f, 1.0f); glVertex3f(1.0f, 1.0f, 1.0f);

// Bottom face (y = -1.0f) glColor3f(1.0f, 0.5f, 0.0f); // Orange glVertex3f(1.0f, -1.0f, 1.0f);
glVertex3f(-1.0f, -1.0f, 1.0f);
glVertex3f(-1.0f, -1.0f, -1.0f);
glVertex3f(1.0f, -1.0f, -1.0f);

// Front face (z = 1.0f) glColor3f(1.0f, 0.0f, 0.0f); // Red glVertex3f(1.0f, 1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f);
glVertex3f(-1.0f, -1.0f, 1.0f);
glVertex3f(1.0f, -1.0f, 1.0f);

// Back face (z = -1.0f) glColor3f(1.0f, 1.0f, 0.0f); // Yellow glVertex3f(1.0f, -1.0f, -1.0f);
glVertex3f(-1.0f, -1.0f, -1.0f);
glVertex3f(-1.0f, 1.0f, -1.0f);
glVertex3f(1.0f, 1.0f, -1.0f);

// Left face (x = -1.0f) glColor3f(0.0f, 0.0f, 1.0f); // Blue glVertex3f(-1.0f, 1.0f, 1.0f);
glVertex3f(-1.0f, 1.0f, -1.0f);
glVertex3f(-1.0f, -1.0f, -1.0f);
glVertex3f(-1.0f, -1.0f, 1.0f);

// Right face (x = 1.0f) glColor3f(1.0f, 0.0f, 1.0f); // Magenta glVertex3f(1.0f, 1.0f, -1.0f); glVertex3f(1.0f, 1.0f, 1.0f); glVertex3f(1.0f, -1.0f, 1.0f);
glVertex3f(1.0f, -1.0f, -1.0f); glEnd(); // End of drawing color-cube

//pyramid
 
glLoadIdentity(); // Reset the model-view matrix
glTranslatef(5.0f, 5.0f, -6.0f); // Move left and into the screen (Translates pyramid by a factor of dx=5, dy=5)
glRotatef(angPyramid, 1.0f, 1.0f, 0.0f); // Rotate about the (1,1,0)-axis glBegin(GL_TRIANGLES); // Begin drawing the pyramid with 4 triangles // Front glColor3f(1.0f, 0.0f, 0.0f); // Red
glVertex3f(0.0f, 1.0f, 0.0f); glColor3f(0.0f, 1.0f, 0.0f); // Green glVertex3f(-1.0f, -1.0f, 1.0f); glColor3f(0.0f, 0.0f, 1.0f); // Blue glVertex3f(1.0f, -1.0f, 1.0f);

// Right
glColor3f(1.0f, 0.0f, 0.0f); // Red glVertex3f(0.0f, 1.0f, 0.0f); glColor3f(0.0f, 0.0f, 1.0f); // Blue glVertex3f(1.0f, -1.0f, 1.0f); glColor3f(0.0f, 1.0f, 0.0f); // Green glVertex3f(1.0f, -1.0f, -1.0f);

// Back
glColor3f(1.0f, 0.0f, 0.0f); // Red glVertex3f(0.0f, 1.0f, 0.0f); glColor3f(0.0f, 1.0f, 0.0f); // Green glVertex3f(1.0f, -1.0f, -1.0f); glColor3f(0.0f, 0.0f, 1.0f); // Blue glVertex3f(-1.0f, -1.0f, -1.0f);

// Left
glColor3f(1.0f, 0.0f, 0.0f); // Red glVertex3f(0.0f, 1.0f, 0.0f); glColor3f(0.0f, 0.0f, 1.0f); // Blue glVertex3f(-1.0f, -1.0f, -1.0f); glColor3f(0.0f, 1.0f, 0.0f); // Green glVertex3f(-1.0f, -1.0f, 1.0f); glEnd(); // Done drawing the pyramid

glutSwapBuffers(); // Swap the front and back frame buffers

// Update rotational angle after each refresh angPyramid += 0.2f;
angCube -= 0.15f;
}

/* Called back when timer expired */ void timer(int value) {
glutPostRedisplay();	//	Post	re-paint	request	to	activate	display() glutTimerFunc(refreshMills, timer, 0); // next timer call milliseconds later }
 
/* Handler for window re-size event. Called back when the window first appears and whenever the window is re-sized with its new width and height */ void reshape(GLsizei width, GLsizei height) { // GLsizei for non-negative integer
// Compute aspect ratio of the new window
if (height == 0) height = 1; // To prevent divide by 0 GLfloat aspect = (GLfloat)width / (GLfloat)height;

// Set the viewport to cover the new window glViewport(0, 0, width, height);

// Set the aspect ratio of the clipping volume to match the viewport glMatrixMode(GL_PROJECTION); // To operate on the Projection matrix glLoadIdentity(); // Reset

// Set up orthographic projection view (glOrtho view plane accordingly and the shapes defined according to view plane)
if (width >= height) {
// aspect >= 1, set the height from -1 to 1, with larger width glOrtho(-3.0 * aspect, 15.0 * aspect, -15.0, 15.0, 0.1, 50);
} else {
// aspect < 1, set the width to -1 to 1, with larger height glOrtho(-3.0, 15.0, -15.0 / aspect, 15.0 / aspect, 0.1, 50);
}
}
/* Main function */
int main(int argc, char** argv) {
glutInit(&argc, argv); // Initialize GLUT
glutInitDisplayMode(GLUT_DOUBLE); // Enable double buffered mode glutInitWindowSize(640, 480); // Set the window's initial width & height glutInitWindowPosition(50, 50); // Position the window's initial top-left corner glutCreateWindow(title); // Create window with the given title glutDisplayFunc(display); // Register callback handler
glutReshapeFunc(reshape); // Register callback handler initGL(); // OpenGL initialization
glutTimerFunc(0, timer, 0); // First timer call
glutMainLoop(); // Enter the infinite event-processing loop return 0;
}
